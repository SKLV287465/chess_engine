\chapter{Possible Improvements}
Above, I have given a brief summary of the thought processes and construction of my chess engine. In retrospect, creating the chess engine tested my software engineering skills more than my algorithmic knowledge and the result was exactly as I had originally planned: a chess engine that was better than what I believed an average chess player was (me). However there is a lot of room for improvements aside from the bugfixing (discussed in the next chapter) that I could not implement due to the time constraints and scope. However I have done research about the theory and plan to implement these concepts either as an extension of this chess engine or if I decide to make a chess engine that runs on cleaner code. Here is a list of improvements that I had been planning to make to the chess engine in the future: 
\section{Quiescence Search}
One of the weaknesses of chess engines that use the min-max algorithm is that we cannot use a high depth due to the NP nature of the algorithm. For example, my chess engine can only feasibly operate on depth 6 on a ryzen 5 7600x cpu, with multithreading enabled. Even with further optimisations, as the time complexity is exponential, going beyond depth 7 would be unattainable. Hence, it is possible for a human to create a attack cycle that is greater than 7 moves long to trick the computer into playing bad moves. To prevent this and to also allow the computers to devise similar such tactics, we can implement something called \textit{Quiescence Search}. Quiescence search is essentially extending the min-max algorithm until the game state is quiet, by considering only moves that take other pieces or check a king until the game state becomes quiet (no such moves can be made). This allows the chess engine to meaningfully deepen the search without incurring too much of a performance penalty.
\section{Zobrist Hashing}
If one comes from a competitive programming background and thinks about how to increase the computational speed of a program, it is likely that they would think about dynamic programming. More specifically how we can cache results that have already computed to reduce the computational latency. A similar concept exists in chess programming where one creates a transposition table to store already discovered moves. One of the most popular ways to do this is through \textit{Zobrist Hashing}, which is a process that essentially converts game states into 64-bit word keys that correspond to values that usually contain the best move from that particular position. This allows for a $O(1)$ lookup for the best move if the same game state is reached, and by keeping a counter it becomes trivial to implement a system that prevents the \textit{threefold repetition rule} by keeping count of how many times the same state is reached.\\\\
Zobrist Hashing is an instance of tabulation hashing which is a method of creating universal families of hash functions through combining table lookup with xor operations. We convert the current chess board into a 64-bit word which becomes the key to be tabulation hashed. The process of tabulation hashing is as follows:
\begin{enumerate}
    \item We choose a $p = 64$ where $p$ is the number of bits in the key
    \item We choose a $q$ which is the number of bits to be in the output
    \item Choose a block size $r \leq p$, where a small $r$ uses less memory but is faster and vice versa
    \item $t = \lceil \frac{p}{r}\rceil$, which becomes the number of blocks that are required to form a key
    \item Create a 2D array $T[2^r][t]$, which is filled with random $q$-bit words
    \item To hash any key $k$, we split $k$ into $r$ bits each then the hash $h(k)$ is:
    \item $h(k) = T[0][k_0] \oplus T[1][k_1] \oplus \dots \oplus T[t - 1][k_{t - 1}]$

\end{enumerate}
\section{Start-Game Database}
Lastly, in order to address one of the major weaknesses of chess engines in general - that they cannot perform well in the start game due to their inability to look far enough into the game to properly develop pieces strategically as a human player would using chess theory, a start game database can be implemented using the many online databases of elite chess games on the internet. The idea would be to compile a set of these elite chess games as a trie data structure and until a certain number of moves, the engine follows the trie randomly to follow how human players would develop their pieces at the beginning. This would allow for the chess engine to have a fast earlygame, thus saving time for the future mid-game where the chess engine can dominate due to the chaotic nature of mid-games in chess. This may offset the viability of ``anti-computer tactics'' that are often utilised in Grandmaster vs Computer games.