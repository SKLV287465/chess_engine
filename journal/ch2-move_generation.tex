\chapter{Move Generation}
Chess engines aim to choose the best possible move that can be taken given the game state. Hence, chess engines typically generate all possible moves for the side whose turn it is. This provides the possibilities for the engine to pick moves from. Further moves are generated recursively from the newly generated moves in order to analyse how certain choices may lead to certain outcomes in the future, and to evaluate which move would be the best to take in the present. Here I will explain how moves are efficiently generated using bitboards as implemented in my chess engine.
\section{Precomputations and Optimisations}
A downside of the bitboard board representation is that it is computationally inefficient in finding whether a piece exists in any given square, whether that piece is black or white and which type of piece it is. Hence, an optimisation I have made is to precompute at the start of every move generation two 64-bit-masks, the first to indicate the squares that are occupied by the white pieces and the second for the black pieces.\\\\
Furthermore, another optimisation that I have made was to generate all \textit{pseudo-legal} moves. Legal moves are moves that can be legally taken as per the rules of chess. The moves that my engine generates include illegal moves such as when the king is in check, moves that don't uncheck the king are not removed in the list of moves returned by my move generation function. The logic behind this is that if the king is in check and an illegal move is made, either the MCTS or min-max algorithm, if correctly implemented would avoid taking that move as it would result in an automatic loss. If we were to generate moves to a depth of 2 in order to check for illegal moves as described, the time complexity of move generation would become $O(n^2)$ as opposed to $O(n)$, where $n$ is the largest number of possible moves. This has greater implications in the search function as the move evaluation function would be called recursively, compounding the increase in latency.
\section{Special Moves}
There are two special moves that can be made in chess: Castling and En passant. Specific rules apply to these moves and therefore we must use additional bits allocated to our board representation.
\subsection{Castling}
Castling is a special move that involves the king and the rook. Castling requires both the king and the rook to be castled with to not have moved, the king to not be in check and there to not exist pieces between the king and the rook. Hence for each side, we must reserve two bits each to indicate whether a respective rook has moved or not and we can set both bits to not allow castling if the king has moved.
\subsection{En Passant}
En Passant is a special move that translates to \textit{``on passing"} and involves the pawns. If playing as white and one of your pawns is on rank 5 and black does \textit{double push} with one of its pawns on an adjacent file, you may take the recently moved pawn as if it had done a single push. The same applies for black on rank 4. Hence it is necessary to keep track of the most recently moved piece as En Passant is only a possible move if the enemy pawn had passed your pawn in the most recent move. My solution to this problem was to keep track of the new position and old position of the most recently moved piece. As there are a total of 8 ranks and files, $3\times 2\times 2 = 12$ bits in total were required to store the old position's rank and file and the new position's rank and file.
\section{Non-Sliding Moves}
Non-Sliding moves in chess are moves that have limited range but can happen regardless of enemy obstruction. This includes moves from pawns, knights and kings. Bitboards allow for very efficient non-sliding move generation as we could generate a non-sliding move for every piece in one cpu instruction then mask out the unavailiable moves through another instruction. For example, we could create every possible \textit{double push} for all the white pawns by left-shifting the white pawn bitboard by 16 bits. Then we could use two \textit{\&=} instructions to mask out possible destinations where the pieces are obstructed by either enemy or friendly pieces.\\\\
After generating all of the possible destinations, I then loop through each bit in the newly created destination bitboard by selecting the least significant 1 bit and then creating a copy of the original board where the the piece moves to the new destination and push the new board/move to the list of generated moves. The selection of the least significant bit is done using the negation operator \textit{-}, then then and operator \textit{\&}. This works as the negative of a number is represented by the two's complement, where the negation is the NOT of the number + 1. Hence the least significant bit is preserved whilst all the higher significance bits are masked out. After the copy is created and pushed into the list, an xor operation \textit{\^} with the destinations bitboard allows me to remove the used destination. A similar process is used to generate the new boards for sliding moves.
\section{Sliding Moves}
Sliding moves in chess are moves that have unlimited range until obstructed by another piece or by the border of the board. Examples include the rook/queen's horizontal and vertical movements and the bishop/queen's diagonal movements. I implemented sliding moves in my engine by hardcoding each possible direction that a piece could move, appropriately shifting the previous location and if not obstructed using the or \textit{|} operation to add to a destination bitboard. This is repeated until the direction is obstructed by a friendly piece. if obstructed by an enemy piece, the \textit{|} operation is done for the destination bitboard but the loop is broken as to not generate moves where the enemy piece is passed.